# 线程
## windows环境下mingw环境问题，

*进程*：运行中的程序
*线程*：进程中的进程
```cpp
#include <iostream>
#include <mingw.thread.h>
#include <string>
void printhelloworld(std::string msg){
    std::cout<<msg<<std::endl;
    return;
}

int main(int argv, char *argc[]){
    std::thread thread1(printhelloworld, "hello thread");
    thread1.join(); //线阻塞调用线程，直到 thread1 所代表的线程执行完成。
    //// 主线程等待 thread1 完成
    return 0;
}
----------------------------------------
hello thread
----------------------------------------
```

## 线程内存问题
```cpp
#include <mingw.thread.h>
#include <iostream>

class A{
public:
    void foo(){
        
        std::cout<<"foo function\nfoo function\n"<<std::endl;
        std::cout<<"foo function\nfoo function\n"<<std::endl;
        std::cout<<"foo function\nfoo function\n"<<std::endl;
    };
};

int main(int argc, char *argv[]){
    A a;
    std::thread thread1(&A::foo, &a);
    // 如果没有thread1.join();主线程会在执行完std::thread thread1(&A::foo, &a);后销毁a对象，导致资源消失
    return 0;
}
-----------------------------------------------------------------
Error: Must join() or detach() a thread before destroying it.
ftoo function
foo function
erminate called without an active exception
-----------------------------------------------------------------
```

## 互斥量实现线程锁
*临界区*：每个并发的进程都有一个代码段，被叫做临界区，这个代码段也是临界区可能会改变并发进程的公告资源数据，更新数据，写入文件等操作；
在并发的进程中，当有一个进程正在执行临界区的代码时候，其他并发的进程是不可以被允许去执行临界区的代码的，换句话说：两个进程是不可以不可能同时执行临界区的内容；
临界区的关键特征：
**共享资源**：临界区内部操作的是一个共享资源，这通常是一个可能被多个线程或进程同时访问的变量、数据结构或 I/O 设备等。
**互斥访问**：临界区必须保证在任意时刻，只有一个线程或进程能够进入并执行临界区代码。其他线程必须等待，直到当前线程退出临界区。
**数据一致性**：临界区的正确同步能够避免数据竞争，确保线程或进程在访问共享资源时，得到的都是正确的数据，并且修改后的结果也能被其他线程正确读取。
```cpp
#include <mingw.thread.h>
#include <mingw.mutex.h>
#include <iostream>

int a = 0;
std::mutex mtx;
void func(){
    for(int i = 0; i<20000; i++){
        mtx.lock();
        a+=1;
        mtx.unlock();
    }
}

int main(int argc, char *argv[]){
    std::thread thread1(func);
    std::thread thread2(func);

    thread1.join();
    thread2.join();

    std::cout<< a << std::endl;

    return 0;
}
```
mutex将需要上锁的程序划为临界区，只允许一个线程访问资源。
```cpp
#include <thread>
#include <mutex>
#include <iostream>
#include <chrono>
int a = 0;
std::timed_mutex mtx;

void func(){
    for(int i = 0; i<2; i++){
        std::unique_lock<std::timed_mutex> um(mtx, std::defer_lock);
        if(um.try_lock_for(std::chrono::seconds(2))){
            std::this_thread::sleep_for(std::chrono::seconds(2));
            a++;
        }
    }
}
int main(){
    std::thread t1(func);
    std::thread t2(func);
    t1.join();
    t2.join();

    std::cout<<a<<std::endl;
    return 0;
}

```
`std::timed_mutex`std::timed_mutex提供了基本的互斥功能，同时支持超时。它允许线程尝试锁定互斥量一段指定的时间。
如果在指定时间内没有获取到锁，线程可以选择放弃等待，执行其他操作。
std::timed_mutex主要提供了两个成员函数用于带超时的锁操作：
**try_lock_for()：**接受一个时间段，如果在这段时间内能够获得锁，则返回true，否则在超时后返回false。
**try_lock_until()：**接受一个绝对时间点，如果在这个时间点之前能够获得锁，则返回true，否则在超时后返回false。

`std::unique_lock`的作用与std::lock_guard基本相同，也是用于管理对互斥量的锁定与解锁，但更加的灵活。std::unique_lock支持std::lock_guard的所用操作，用法也基本相同，同时还支持一些其他的操作，包括延迟锁定、条件等待、尝试锁定、锁定时长、使用权转移、手动解锁。

**unique_lock的第二个参数:**
std::adopt_lock
表示互斥量已将lock了，线程已经获得了互斥量的所有权，不需要再使用unique_lock获取锁。这个功能lock_guard也可以使用，与unique_lock中的含义相同。

**std::defer_lock**
std::defer_lock的作用是延迟锁的获取，表示unique_lock初始时不要尝试获取锁，而是当调用lock或者try_lock成员函数时再获取锁。使用std::defer_lock同样需要确保线程还未获得锁。

**unique_lock的成员函数**
**lock()和unlock()**
unique_lock对象也可以显式的调用lock()和unlock()去获取和释放锁。

**try_lock()**
尝试获取锁，如果获取成功则返回true，失败则返回false。一般与defer_lock配合使用。

**try_lock_for()**
尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间。

**release()**
释放std::unique对互斥量的所用权，并返回管理的mutex的对象指针。使用release()后，需要手动的调用互斥量的unlock()成员函数释放锁。


unique_lock所有权的传递
与unique_ptr相似，unique_lock对mutex对象的所用权可以转移，但不可以复制。同一时间，mutex的所有权仅能被一个unique_lock拥有。可以使用std::move()转移unique_lock的所有权。

## 单例模式和线程安全
在c++中
```cpp
#include <iostream>
#include <thread>
#include <mutex>

class Log {
public:
    Log() = default;
    Log(const Log& log) = delete;
    Log& operator=(const Log& log) = delete;

    static Log& GetInstance() {
        static std::once_flag initInstanceFlag;
        std::call_once(initInstanceFlag, []() {
            logInstance = new Log();
        });      //lamba表达式
        return *logInstance;
    } //保证在多线程环境下某段代码（通常是单例的初始化）只会被执行一次

    void PrintLog(const std::string& msg) {
        std::cout << "Log message: " << msg << std::endl;
    }

private:
    static Log* logInstance;  //静态函数只能操作静态变量；
};

Log* Log::logInstance = nullptr;

int main() {
    std::thread t1([]() {
        Log::GetInstance().PrintLog("Thread 1");
    });

    std::thread t2([]() {
        Log::GetInstance().PrintLog("Thread 2");
    });

    t1.join();
    t2.join();
}
```